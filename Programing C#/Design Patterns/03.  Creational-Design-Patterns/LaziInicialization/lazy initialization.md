# Lazy initialization Pattern

## Мотивация

 * В много случаи се достъпват данни или създават обекти, от които или нямаме нужда веднага или никога не използваме. Този проблем се решава с така наречният шаблон за дизайн 'Lazy initialization pattern', който предотвратява излишно използване на ресурси от програмата ни.
 
## Цел

 * Служи за  използване на данните в момента, в който имаме нужда от тях

## Приложение

* Пример 1:

Нека имаме база с данни. В нея имаме таблица, която се грижи за данните на един студент в училище. Студентът има поредица от курсове, учители, домашни, изпити, оценки и т.н. Използвайки 'Entity Framework' ние имаме възможността да работим с класа 'Student' като всеки един обект от този клас ни представлява запис от базата с данни. Какво би станало ако имаме нужда от оценките на студентите. Ще издърпаме висчки данни за всеки един студент и освен оценките му ще имаме и всичката друга ненужна информация, която хем ще заеме излишна памет, хем ще забави преноса на данни заради обема си. Това би било така, ако 'Entity framework' е писан от студенти преди изпит по КПК :D Но тъй като не е, при създаването на навигационни property-та(това са полета, които сочат към други таблици - например 'курсове', 'учители') те са дефинират като 'virtual' такива и дават възможност вътрешно 'EF' да създава 'proxy' класове, които представляват основните класове(Student)и доставят данните само, когато имаме нужда от тях или с други думи, когато напишем 'currentStudent.grades' и активираме 'get'-a на полето.
 

## Известни употреби

* Entity Framework
* Singleton design pattern
* IQueryable интерфейс - позволява филтрацията да се извършва в базата с данни, след което да се материализира в RAM паметта при нуждата от данните(lazy loading)


## Имплментация 

```
public class Customer
{
    public int CustomerID { get; set; }
    public string Name { get; set; }
    private IEnumerable<Order> _orders;

    public IEnumerable<Order> Orders
    {
        get
        {
            if (_orders == null)
            {
                _orders = OrdersDatabase.GetOrders(CustomerID);
            }
            return _orders;
        }
    }

    // Constructor
    public Customer(int id, string name)
    {
        CustomerID = id;
        Name = name;
    }
} 
  ```

## Последствия
* Спестява използвани ресурси.
* Предотвратява наличието на излишна и ненужна информация

## Сродни модели
* Не мисля, че има

## Проблеми

* Неправилното му използване. При достъпът до скромни ресурси, няма нужда излишно да усложняваме кода ни.

